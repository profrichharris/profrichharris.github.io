---
title: "Thematic maps in R"
execute: 
  warning: false
  message: false
---

```{r}
#| include: false
installed <- installed.packages()[,1]
required <- c("tidyverse", "sf", "RColorBrewer", "gridExtra", "classInt", "ggplot2",
              "ggspatial", "scales", "remotes", "ggiraph", "tmap", "gifski", "mapview")
install <- required[!(required %in% installed)]
if(length(install)) install.packages(install, dependencies = TRUE, repos = "https://cloud.r-project.org")
```

## Introduction

There are lots of ways to produce maps in R. But, however, they are drawn, two things are usually needed to produce a choropleth map of the sort seen in previous sessions: some data and a map to join the data to. Once we have those, R offers plenty of options to produce quick or publication quality maps, which may have either static or dynamic content. The two we shall focus on are [ggplot2](https://ggplot2-book.org/maps.html){target="_blank"} and [tmap](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html){target="_blank"}.

## Getting Started

As before, if you are keeping all the files and outputs from these exercises together in an R Project (which is a good idea) then open that Project now.

### Load the data

Let's begin with the easy bit and load the data, which are from [http://superweb.statssa.gov.za](https://superweb.statssa.gov.za/webapi/jsf/login.xhtml){target="_blank"}. These includes the variable `No_schooling` which is the percentage of the population without schooling per South African municipality in 2011.

```{r}
# A quick check to see if the Tidyverse packages are installed...
installed <- installed.packages()[,1]
if(!("tidyverse" %in% installed)) install.packages("tidyverse",
                                                   dependencies = TRUE)
require(tidyverse)

education <- read_csv("https://github.com/profrichharris/profrichharris.github.io/raw/main/MandM/data/education.csv")
slice_head(education, n = 3)
```

### Loading the map

Next we need a 'blank map' of the same South African municipalities that are included in the data above. It is read-in below in [geoJSON](https://en.wikipedia.org/wiki/GeoJSON){target="_blank"} format but it would not have been unusual if it had been in .shp (shapefile) or .kml format, instead. The source of the data is [https://dataportal-mdb-sa.opendata.arcgis.com/](https://dataportal-mdb-sa.opendata.arcgis.com/datasets/439676d2f2f146889a6eb92da80db780_0/about){target="_blank"}. There are several ways of reading this file into R but it is better to use the `sf` package because older options such as `maptools::readShapePoly()` (which was for reading shapefiles) or `rgdal::readOGR` are either deprecated already or in the process of being retired.

```{r}
if(!("proxy" %in% installed)) install.packages("proxy")
if(!("sf" %in% installed)) install.packages("sf", dependencies = TRUE)
require(sf)

municipal <- read_sf("https://github.com/profrichharris/profrichharris.github.io/raw/main/MandM/boundary%20files/MDB_Local_Municipal_Boundary_2011.geojson")
```

</br>
If we now look at the top of the `municipal` object then we find it is of class `sf`, which is short for [simple features](https://r-spatial.github.io/sf/articles/sf1.html){target="_blank"}. It has a vector geometry (it is of type multipolygon) and has its coordinate reference system (CRS) set as [WGS 84](https://gisgeography.com/wgs84-world-geodetic-system/){target="_blank"}. It also contains some attribute data, although not the schooling data we are looking to map.

```{r}
slice_head(municipal, n = 1)
```

Here are just the attribute data

```{r}
st_drop_geometry(municipal) |>
  slice_head(n = 5)
```

And here is the 'blank' map.

```{r}
par(mai=c(0, 0, 0, 0))  # Removes the plot margins
municipal |>
  st_geometry() |>
  plot()
```

Had it been necessary to set the coordinate reference system then the function `st_set_crs()` would be used. Instead, and just for fun, we will change it: here is the map transformed on to a 'south up' coordinate reference system, achieved by changing its [EPSG code](https://epsg.io/){target="_blank"} to 2050 with the function `st_transform()`. 

```{r}
par(mai=c(0, 0, 0, 0))
municipal |>
  st_transform(2050) |>
  st_geometry() |>
  plot()
```

![](hazard.gif){width=75}

<font size = 3>Note how functions with the `sf` library tend to start with `st_`. Personally, I find this slightly confusing and I am not sure it doesn't make it harder to find what I looking for in the package's help pages but it is consistent for the functions and methods that operate on spatial data and is, I believe, short for spatial type.</font>

### sf and sp

At the risk of over-simplification, `sf` (simple features) can be viewed as a successor to the earlier `sp` (spatial) and related packages, which are well documented in the book [Applied Spatial Data Analysis with R](https://link.springer.com/book/10.1007/978-1-4614-7618-4){target="_blank"}. Sometimes other packages are still reliant on `sp` and so the spatial objects need to be changed into its native format prior to use. 

```{r}
# From sf to sp
municipal_sp <- as(municipal, "Spatial")
class(municipal_sp)
# From sp to sf
municipal_sf <- st_as_sf(municipal_sp)
class(municipal_sf)
```

## Joining the attribute data to the map

If we look again at the map and schooling data, we find that they have two variables in common which suggests a means to join them together based on a common field.

```{r}
intersect(names(municipal), names(education))
```

This is encouraging but, in this example, we need to be careful using the municipal names because not all of those in the map are in the education data or vice versa.

```{r}
# anti_join() return all rows from x without a match in y
anti_join(municipal, education, by = "LocalMunicipalityName")
anti_join(education, municipal, by = "LocalMunicipalityName")
```

Fortunately, the municipal codes are consistent even where the names are not.

```{r}
anti_join(municipal, education, by = "LocalMunicipalityCode")
anti_join(education, municipal, by = "LocalMunicipalityCode")
```

We therefore join the data to the map using the variable `LocalMunicipalityCode` and check that the schooling data are now attached to the map. They are.

```{r}
municipal <- left_join(municipal, education, by = "LocalMunicipalityCode")
names(municipal)
```

![](hazard.gif){width=75}

<font size = 3>Note that the variables `LocalMunicipalityName.x` and `LocalMunicipalityName.y` have been created in the process of the join. This is because there are non-joined variables with duplicated names in the data, i.e. `LocalMunicipalityName` from `municipal` and `LocalMunicipalityName` from `education`.</font>

## Mapping the data

### Using `plot{sf}`

The 'one line' way of plotting the data is to use the in-built `plot()` function for `sf`.

```{r}
plot(municipal["No_schooling"])
```

As 'rough and ready' way to check for spatial variation and patterns in the data, it is quick and easy. It is important to specify the variable(s) you wish to include in the plot or else it will plot them all up to the value specified by the argument `max.plot`, which has a default of nine:

```{r}
plot(municipal)
```

</br>
The map can be customised. For example,

```{r}
if(!("RColorBrewer" %in% installed)) install.packages("RColorBrewer",
                                                      dependencies = TRUE)
require(RColorBrewer)

plot(municipal["No_schooling"], key.pos = 1, breaks = "jenks", nbreaks = 7,
     pal = rev(brewer.pal(7, "RdYlBu")),
     graticule = TRUE, axes = TRUE,
     main = "Percentage of Population with No Schooling")
```

For the above map [RColorBrewer package](https://cran.r-project.org/web/packages/RColorBrewer/index.html){target="_blank"} has been used to create a diverging red-yellow-blue colour palette that is reversed using the function `rev` so that red is assigned to the highest values, not lowest.

`RColorBrewer` provides colour palettes based on [https://colorbrewer2.org/](https://colorbrewer2.org/){target="_blank"}. A 'natural breaks' (jenks) classification with 7 colours has been used (`breaks = "jenks"`). Compare it with the result from using `breaks = "equal"`,

```{r}
plot(municipal["No_schooling"], key.pos = 1, breaks = "equal", nbreaks = 7,
     pal = rev(brewer.pal(7, "RdYlBu")),
     graticule = TRUE, axes = TRUE,
     main = "Percentage of Population with No Schooling")
```

... or `breaks = "quantile"`.

```{r}
plot(municipal["No_schooling"], key.pos = 1, breaks = "quantile", nbreaks = 7,
     pal = rev(brewer.pal(7, "RdYlBu")),
     graticule = TRUE, axes = TRUE,
     main = "% of Population with No Schooling")
```

Clearly the maps do not all appear alike. The geographical patterns and therefore the geographical information that we view in the map are a function of how the map is constructed, including the number, colouring and widths (ranges) of the map classes. Ideally, these should be set to reflect the distribution of the data and what is being look for in it.

The following histograms show the break points in the distributions used in the various maps. The code works by creating a list of plots (specifically, a list of ggplots, see below) -- one plot each for the jenks, equal and quantile styles -- and then using a package called `gridExtra` to arrange those plots into a single grid. However, the code matters less than what it reveals, which is that [Jenks](http://wiki.gis.com/wiki/index.php/Jenks_Natural_Breaks_Classification){target="_blank"} or other 'natural breaks' classifications are reasonably good for identifying break points that reflect the distribution of the data in the absence of the user having cause to set those break points in some other way.

```{r, message=FALSE, warning=FALSE, fig.height=6}
if(!("gridExtra" %in% installed)) install.packages("gridExtra",
                                                   dependencies = TRUE)
if(!("classInt" %in% installed)) install.packages("classInt",
                                                  dependencies = TRUE)

require(gridExtra)
require(classInt)

styles <- c("jenks", "equal", "quantile")
g <- lapply(styles, \(x) {
        ggplot(municipal, aes(x = No_schooling)) +
        geom_histogram(fill = "light grey") +
        xlab("% of Population with No Schooling") +
        geom_vline(xintercept = classIntervals(municipal$No_schooling,
                                               n = 7, style = x)$brks,
                   col = "dark red") +
        geom_rug() +
        theme_minimal() +
        ggtitle(paste(x,"classification"))
    })
grid.arrange(grobs = g)
```

</br>
For further information on using `plot{sf}` see [here](https://r-spatial.github.io/sf/articles/sf5.html){target="_blank"} and look at the help menu, `?sf::plot`.

### Using `ggplot2`

Whilst the `plot()` function for `sf` objects is useful for producing quick maps, I tend to prefer [ggplot2](https://ggplot2.tidyverse.org/){target="blank"} for better quality ones that I am wanting to customise or annotate in particular ways. We already have seen examples of `ggplot2` output in earlier sessions and also in the histograms above.

ggplot2 is based on [The Grammar of Graphics](https://link.springer.com/book/10.1007/0-387-28695-0){target="_blank"}. I find it easiest to think of it in four stages:

1. Say which data are to be plotted;
2. Say which aesthetics of the chart (e.g. colour, line type, point size) will vary with the data;
3. Say which types of plots (which 'geoms') are to feature in the chart;
4. (Optional) change other attributes of the chart to add titles, rename the axis labels, and so forth.

In the code chunk below, those four stages are applied to a boxplot showing the distribution of the no schooling variable by South African Provinces.

First, the `data = municipal`.
Second, consulting with [the ggplot2 cheatsheet](https://www.rstudio.com/resources/cheatsheets/){target="_blank"}, I find that the aesthetics, `aes()`, for the boxplot, require a discrete `x` and a continuous `y`, which are provided by `ProvinceName` and `No_schooling`, respectively. `ProvinceName` has also been used to assign a `fill` colour to each box.
Third, the optional changes arise from me preferring `theme_minimal()` to the default style, although I have then modified it to remove the legend, change the angle of the text on the x-axis, remove the x-axis label and change the y-axis label.

```{r}
ggplot(data = municipal, aes(x = ProvinceName, y = No_schooling,
                             fill = ProvinceName)) +
  geom_boxplot() +
  theme_minimal() +
  theme(legend.position = "none", axis.text.x = element_text(angle = 45)) +
  xlab(element_blank()) +
  ylab("% No schooling within municipalities")
```

</br>
Let's now take that process and apply it to create a map, using the same `RColorBrewer` colour palette as previously and adding the map using `geom_sf` (for a full list of geoms available for ggplot2 see [here](https://ggplot2.tidyverse.org/reference/){target="_blank"}). The line `scale_fill_distiller` is an easy way to shade the map using the colour palette from `RColorBrewer`. Modifying the theme with the arguments `theme(... = element_blank(), ...)` suppress the axis titles. What `labs()` does should be obvious.


```{r}
ggplot(municipal, aes(fill = No_schooling)) +
  geom_sf() +
  scale_fill_distiller("%", palette = "RdYlBu") +
  theme_minimal() +
  theme(axis.title.x = element_blank(), axis.title.y = element_blank()) +
  labs(
    title = "Percentage of Population with No Schooling",
    subtitle = "2011 South African Census Data",
    caption = "Source: Statistics South Africa"
  )  
```

</br>
Presently the map has a continuous shading scheme. This can be changed to discrete map classes and colours by converting the continuous `municipal$No_schooling` variable to a factor, using the `cut()` function, here with break points found using `ClassIntervals(style = "jenks")`. Because we have changed from continuous to discrete data but still want to use an `RColorBrewer` palette, so `scale_fill_brewer()` replaces `scale_fill_distiller()`, wherein the argument `direction = -1` reverses the `RdYlBu` palette so that the highest values are coloured red. Adding `guides(fill = guide_legend(reverse = TRUE))` reverses the legend so that the highest values are on top in the legend, which is another preference of mine.

```{r}
# Find the break points in the distribution using a Jenks classification
brks <- classIntervals(municipal$No_schooling, n = 7, style = "jenks")$brks

# Factor the No_schooling variable using those break points
municipal$No_schooling_gp <- cut(municipal$No_schooling, brks,
                                 include.lowest = TRUE)

ggplot(municipal, aes(fill = No_schooling_gp)) +
  geom_sf() +
  scale_fill_brewer("%", palette = "RdYlBu", direction = -1) +
  theme_minimal() +
  theme(axis.title.x = element_blank(), axis.title.y = element_blank()) +
  guides(fill = guide_legend(reverse = TRUE)) +
  labs(
    title = "Percentage of Population with No Schooling",
    subtitle = "2011 South African Census Data",
    caption = "Source: Statistics South Africa"
  ) 
```

At the point, we may note that the four stages of the map production that I referred to earlier was an over-simplification and we can add a fifth:

1. Say which data are to be plotted;
2. Say which aesthetics of the chart (e.g. colour, line type, point size) will vary with the data;
3. Say which types of plots (which 'geoms') are to feature in the chart -- geom_sf for mapping;
4. 'Scale' the data -- in the above examples, link the mapped variables to map classes and colour codes. The scaling is what `scale_fill_...` were doing;
5. (Optional) change other attributes of the chart to add titles, rename the axis labels, and so forth.

#### Annotating the map with `ggspatial`

Having created the basic map using `ggplot2`, we can add some additional map elements using [ggspatial](https://cran.r-project.org/web/packages/ggspatial/index.html){target="_blank"} which provides some extra cartographic functions. The following code chunk adds a backdrop to the map. Different backgrounds (alternative map tiles) can be chosen from the list at `rosm::osm.types()`; see [here](http://leaflet-extras.github.io/leaflet-providers/preview/index.html){target="_blank"} for what they look like.

Before running the code, we may note a change from the previous code chunk (above) which is in addition to installing and requiring `ggspatial` and adding the map tile as a backdrop. Specifically, if you look at the previous code chunk you will find that the data, `municipal` are handed-to ggplot in the top line `ggplot(municipal, ...)`. In essence, this sets municipal as a global parameter: it is where ggplot will, by default, look for the variable called for in `aes(fill = No_schooling_gp)` and where it will look for other variables too. Whilst this would work just fine in the code below, too, a little later I introduce a second `geom_sf` into the plot and no longer want `municipal` to be the default choice for all the aesthetics of the chart. To pre-empt any problems that might otherwise arise, I no longer specify as the default dataset in `ggplot()` but, instead, specifically name `municipal` as the `fill` data, in the line `geom_sf(data = municipal, aes(fill = No_schooling_gp))`, which will leave me free to associate other data with different aesthetics in due course.

```{r}
if(!("ggspatial" %in% installed)) install.packages("ggspatial",
                                                   dependencies = TRUE)
require(ggspatial)

ggplot() +
  annotation_map_tile(type = "cartolight", progress = "none") +
  geom_sf(data = municipal, aes(fill = No_schooling_gp)) +
  scale_fill_brewer("%", palette = "RdYlBu", direction = -1) +
  theme_minimal() +
  theme(axis.title.x = element_blank(), axis.title.y = element_blank()) +
  guides(fill = guide_legend(reverse = TRUE)) +
  labs(
    title = "Percentage of Population with No Schooling",
    subtitle = "2011 South African Census Data",
    caption = "Source: Statistics South Africa"
  ) 
```

</br>
A north arrow and a scale bar can also be added, although including the scale bar generates a warning because the map-to-true life distance ratio is not actually constant across the map but varies with longitude and latitude. The argument, `location = "tl"` is short for top left; `location = "br"` for bottom right. See `?annotation_north_arrow` and `?annotation_scale` for further details and options. Note also the use of the `last_plot()` function to more easily add content to the last ggplot.

```{r}
last_plot() +
  annotation_north_arrow(location = "tl",
                         style = north_arrow_minimal(text_size = 14)) +
  annotation_scale(location = "br", style = "ticks")
```

<br>
In the next example, the locations of South African cities are added to the map, with a symbol drawn in proportion to their population size. The source of the data is a [shapefile](https://desktop.arcgis.com/en/arcmap/latest/manage-data/shapefiles/what-is-a-shapefile.htm){target="_blank"} from [https://data.humdata.org/dataset/hotosm_zaf_populated_places](https://data.humdata.org/dataset/hotosm_zaf_populated_places){target="_blank"}. The symbol shape that is specified by `pch = 3` has the same numeric coding as those in `?graphics::points` (i.e. 0 is a square, 1, is a circle, 2 is a triangle, and so forth).

![](pch.png)

The function `scales::label_comma()` forces decimal display of numbers to avoid displaying scientific notation. 

```{r}
if(!("scales" %in% installed)) install.packages("scales", dependencies = TRUE)

download.file("https://github.com/profrichharris/profrichharris.github.io/blob/main/MandM/boundary%20files/hotosm_zaf_populated_places_points_shp.zip?raw=true",
              "cities.zip", mode = "wb", quiet = TRUE)
unzip("cities.zip")

read_sf("hotosm_zaf_populated_places_points.shp") |>
  filter(place == "city") |>
  mutate(population = as.numeric(population)) ->
  cities

last_plot() +
  geom_sf(data = cities, aes(size = population), pch = 3) +
  scale_size("Population", labels = scales::label_comma())
```

![](hazard.gif){width=75}

<font size = 3>Slightly confusingly, a shapefile actually consists [of at least three files](https://www.esri.com/content/dam/esrisites/sitecore-archive/Files/Pdfs/library/whitepapers/pdfs/shapefile.pdf){target="_blank"}, one with the extension .shp (the coordinate/shape data), one .shx (an index file) and one .dbf (the attribute data). If you use a shapefile you need to make sure you download all of them and keep them together in the same folder.</font>

#### Labelling using `ggsflabel`

Nice labelling of the cities is provided by [ggsflabel](https://github.com/yutannihilation/ggsflabel){target="_blank"}, in this example using a pipe `|>` to filter and only label cities with over a million population. The function `geom_sf_label_repel()` is designed to stop labels from being placed over each other. We could use `last_plot()` again to create this map but, instead, here is the code in full:

```{r}
if(!("remotes" %in% installed)) install.packages("remotes", dependencies = TRUE)
if(!("ggsflabel" %in% installed)) remotes::install_github("yutannihilation/ggsflabel")
require(ggsflabel)

ggplot() +
  annotation_map_tile(type = "cartolight", progress = "none") +
  geom_sf(data = municipal, aes(fill = No_schooling_gp)) +
  scale_fill_brewer("%", palette = "RdYlBu", direction = -1) +
    geom_sf(data = cities, aes(size = population), pch = 3) +
  scale_size("Population", labels = scales::label_comma()) +
  geom_sf_label_repel(data = cities |> filter(population > 1e6),
                    aes(label = name), alpha = 0.7, size = 3) +
  theme_minimal() +
  theme(axis.title.x = element_blank(), axis.title.y = element_blank()) +
  guides(fill = guide_legend(reverse = TRUE)) +
  labs(
    title = "Percentage of Population with No Schooling",
    subtitle = "2011 South African Census Data",
    caption = "Source: Statistics South Africa"
  ) 
```

#### Saving the map

Having created the map, it can now be saved. If you are not using an R Project to save your files into, you may wish to change your working directory before saving the graphic, using `setwd(dir)` and substituting `dir` with the pathname to the preferred directory, or by using Session -> Set Working Directory -> Choose Directory from the dropdown menus. Once you have done so, the `last_plot()` is easily saved using the function `ggsave()`. For example, in .pdf format, to a print quality,

```{r}
#| eval: false
ggsave("no_schooling.pdf", device = "pdf", width = 6, units = "in",
       dpi = "print")
```

Alternatively, we can write directly to a graphics device, using one of the functions `bmp()`, `jpeg()`, `png()`, `tiff()` or `pdf()`. For instance, 

```{r}
#| eval: false
jpeg("no_schooling.jpg", res = 72)
last_plot()
dev.off()
```

#### Creating an interactive map using `ggiraph`

So far all the maps we have created have been static. This is obviously better for anything that will be printed but, for a website or similar, we may wish to include more 'interaction'. The package [ggiraph](https://cran.r-project.org/web/packages/ggiraph/index.html){target="_blank"} package creates dynamic `ggplot2` graphs and we can use it to create an interactive map where information about the areas appears as we brush over those areas on the map with the mouse pointer. This is achieved by replacing, in the code, `geom_sf()` with the `geom_sf_interactive()` function from `ggiraph`, specifying the text to show with the `tooltip` (the example below pastes a number of character elements together without a space between them, hence `paste0()` but does include a carriage return, `\n`) and rendering the resulting ggplot2 object with `girafe()`.

```{r}
if(!("ggiraph" %in% installed)) install.packages("ggiraph", dependencies = TRUE)
require(ggiraph)

g <- ggplot(data = municipal, aes(fill = No_schooling_gp)) +
  annotation_map_tile(type = "cartolight", progress = "none") +
  geom_sf_interactive(aes(tooltip = paste0(LocalMunicipalityName.x, "\n",
                                           round(No_schooling,1), "%"),
                             fill = No_schooling_gp)) +
  scale_fill_brewer("%", palette = "RdYlBu", direction = -1) +
  theme_minimal() +
  theme(axis.title.x = element_blank(), axis.title.y = element_blank()) +
  guides(fill = guide_legend(reverse = TRUE)) +
  labs(
    title = "Percentage of Population with No Schooling",
    subtitle = "2011 South African Census Data",
    caption = "Source: Statistics South Africa"
  ) +
  annotation_north_arrow(location = "tl",
                         style = north_arrow_minimal(text_size = 14)) +
  annotation_scale(location = "br", style = "ticks")

girafe(ggobj = g)
```

### Using `tmap`

Clearly there is a lot of scope to produce high quality maps using `ggplot2` and various associated packages. However, it has a rival, in [tmap](https://cran.r-project.org/web/packages/tmap/index.html), which is arguably easier to use. Like ggplot2, `tmap` adopts the Grammar of Graphics but approaches it in a slightly different way that uses layers: it builds-up the layers of the graphic by first specifying a spatial object or background, then doing things to the map based on it, then specifying another spatial object and/or other map elements to do things with, and so forth. The types of layers available can be viewed [here](https://r-tmap.github.io/tmap-book/layers.html){target="_blank"} and [here](https://r-tmap.github.io/tmap-book/layout.html#attributes-layers){target="_blank"}. A brief introduction to tmap is available [here](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html){target="_blank"}.

The code chunk a little further below builds-up the layers of the map to produce one quite like that previously created in ggplot2. First, however, there is a error in the geometry of the underlying municipal map file to deal with:

```{r}
all(st_is_valid(municipal))
```

The problem lies in the 128th area, where one edge crosses another,

```{r}
st_is_valid(municipal[128,], reason = TRUE)
```

`tmap` is less forgiving of this error than `ggplot2` is. A temporary 'fix' -- more of a side-step really -- is achieved by changing the coordinate reference system, which presently is using [EPSG: 4326](https://epsg.io/4326){target="_blank"} (you can see this with `st_crs(municipal)`), to [EPSG: 3857](https://epsg.io/3857){target="_blank"}.

```{r}
municipal <- st_transform(municipal, 3857)
all(st_is_valid(municipal))
```

Now we can produce the plot,

```{r}
#| fig-height: 6
if(!("tmap" %in% installed)) install.packages("tmap", dependencies = TRUE)
require(tmap)

tmap_mode("plot")

tm_graticules(col = "light grey") +
  tm_shape(municipal, is.master = TRUE) +
  tm_fill("No_schooling", palette = "-RdYlBu", title = "%", style = "jenks",
          n = 7) +
  tm_borders(col = "black") +
  tm_shape(cities) +
  tm_dots(size = "population", shape = 3) +
  tm_shape(cities |> filter(population > 1e6)) + 
  tm_text("name", bg.color = "white", auto.placement = TRUE, bg.alpha = 0.6) +
  tm_legend(title = "Percentage of Population with No Schooling",
            bg.color = "white", bg.alpha = 0.7) +
  tm_compass(type = "arrow", position = c("right", "top")) +
  tm_scale_bar(position = c("right", "bottom"), bg.color = "white") +
  tm_credits("Source: 2011 Census / Statistics South Africa",
             bg.color = "white")
```          

</br>
The map looks pretty good and can be saved using the function `tmap_save`. For example,

```{r}
tmap_save(tmap_last(), "no_schooling2.jpg", width = 7, units = "in")
```

However, there is a cartographic irritation. If you look at the map classes, they are non-unique: e.g. 5.64 to 9.87, 9.87 to 13.38, 13.38 to 17.19, and so forth. Which category would a value of 9.87 (or 13.38, etc.) fall into?

To solve this problem, we can do what we did for the ggplots, which is to create a factor from the `municipal$No_schooling` variable, which is what the first two lines of code below do. The third line reverses the order of the factors, so that the highest not lowest valued group is treated as the first level and so forth. The reason I have added this is because of my preference for the highest values to appear top in the legend.

```{r}
#| fig-height: 6
brks <- classIntervals(municipal$No_schooling, n = 7, style = "jenks")$brks
municipal$No_schooling_gp <- cut(municipal$No_schooling, brks,
                                 include.lowest = TRUE)
municipal$No_schooling_gp <- factor(municipal$No_schooling_gp,
                                levels = rev(levels(municipal$No_schooling_gp)))

tm_graticules(col = "lightgrey") +
  tm_shape(municipal) +
  tm_fill("No_schooling_gp", palette = "RdYlBu", title = "%") +
  tm_borders(col = "black") +
  tm_shape(cities) +
  tm_dots(size = "population", shape = 3) +
  tm_shape(cities %>% filter(population > 1e6)) + 
  tm_text("name", bg.color = "white", auto.placement = TRUE, bg.alpha = 0.6) +
  tm_legend(title = "Percentage of Population with No Schooling",
            bg.color = "white", bg.alpha = 0.7) +
  tm_compass(type = "arrow", position = c("right", "top")) +
  tm_scale_bar(position = c("right", "bottom"), bg.color = "white") +
  tm_credits("Source: 2011 Census / Statistics South Africa",
             bg.color = "white")
```

</br>
Where `tmap` really excels is in rendering interactive maps to [leaflet](https://leafletjs.com/){target="_blank"} by changing the `tmap_mode` from `tmap_mode("plot")`to `tmap_mode("view")`. The following allows panning, can be zoomed in and out of, can have different map layers displayed (move your mouse cursor over the map layers icon to do so) and, if you right click on any of the areas shown, will bring-up information about them. Unfortunately, it also reveals that the earlier 'fix' to the `municipal` object doesn't work here so I have omitted the problem area, although that isn't much of a solution.

```{r}
tmap_mode("view")

tm_basemap(c(Stamen = "Stamen.Watercolor",
             Carto = "CartoDB",
             OSM = "OpenStreetMap")) +
  tm_shape(municipal[-128,], name = "municipalities") +
  tm_fill("No_schooling_gp", palette = "RdYlBu", title = "%",
          id = "LocalMunicipalityName.x",
          popup.vars = c("% No schooling:" = "No_schooling",
                         "Province: " = "ProvinceName"),
          popup.format = list(digits = 1)) +
  tm_borders(col = "black") +
  tm_shape(cities) +
  tm_dots(size = "population",
          id = "name",
          popup.vars = c("Population: " = "population")) +
  tm_legend(title = "Percentage of Population with No Schooling",
            bg.color = "white", bg.alpha = 0.7) +
  tm_scale_bar(position = c("right", "bottom"), bg.color = "white") +
  tm_view(view.legend.position = c("right", "bottom"))
```

</br>
![](hazard.gif){width=75}

<font size = 3>Different layers are available dependent upon the `tmap_mode`. For example, there is no straightforward way of adding a maptile (`tm_basemap`) as the backdrop to a `"plot"` map, nor a compass (`tm_compass`) or a scale bar (`tm_scale_bar`) to a `"view"`.</font> 
 
</br> 
We can also have some fun! Here is an animated map where the animation is produced from a combination of the `tm_facets(along = "ProvinceName", free.coords = FALSE)` layer and the use of `tmap_animation()` function. Notice how I add `municipal` to the map twice, as two separate layers. The first is to provide a general backdrop to the map with all the municipalities shaded grey. They second is linked to the animation with the municipalities shaded by the percentage of their population without schooling.

```{r}
#| eval: false
if(!("gifski" %in% installed)) install.packages("gifski", dependencies = TRUE)

tmap_mode("plot")

t <- tm_graticules(col = "light grey") +
  tm_shape(municipal) +
  tm_polygons(col = "grey", border.col = "black") +
  tm_shape(municipal) +
  tm_fill("No_schooling_gp", palette = "RdYlBu", title = "%") +
  tm_borders(col = "white") +
  tm_facets(along = "ProvinceName", free.coords = FALSE) +
  tm_legend(title = "Percentage of Population with No Schooling",
            bg.color = "white", bg.alpha = 0.7) +
  tm_compass(type = "arrow", position = c("right", "top")) +
  tm_scale_bar(position = c("right", "bottom"), bg.color = "white") +
  tm_credits("Source: 2011 Census / Statistics South Africa",
             bg.color = "white")

tmap_animation(t, delay = 100)
```

![](no_schooling.gif)
</br>
![](hazard.gif){width=75}

<font size = 3>The animation may be saved as a .gif file by including the argument `filename` (see `?tmap_animation`).</font>

</br>
Faceting can also be used on static maps, as in the following example, where `tm_facets(by = "ProvinceName", free.coords = TRUE)` creates a choropleth map for each Province, with a common legend, positioned outside each provincial map provided by `tm_layout(legend.outside.position = "bottom")`.

```{r}
#| eval: false
tmap_mode("plot")

tm_graticules(col = "light grey") +
  tm_shape(municipal) +
  tm_fill("No_schooling_gp", palette = "RdYlBu",
          title = "% Population with No Schooling",
          legend.is.portrait = FALSE) +
  tm_borders(col = "white") +
  tm_facets(by = "ProvinceName", free.coords = TRUE) +
  tm_compass(type = "arrow", position = c("right", "top")) +
  tm_scale_bar(position = c("right", "bottom")) +
  tm_layout(legend.outside.position = "bottom")
```

![](facet_map.jpg)

## Geofacets

To this point of the session we have been using maps to represent the spatial distribution of one or more variables whose values are plotted as an attribute of the map such as colour or shape size. A different approach is offered by the [geofacet](https://hafen.github.io/geofacet/index.html){target="_blank"} package which uses geography as a 'placeholder' to position graphical summaries of data for different parts of the map. The idea is to flexibly visualise data for different geographical regions by providing a `ggplot2` faceting function `facet_geo()` that works just like ggplot2’s built-in faceting, except that the resulting arrangement of panels follows a grid that mimics the original geographic topology as closely as possible.

Here is an example of it in use, showing the distribution of municipalities within South African provinces in terms of the percentage of the population with higher education (university) qualifications.

```{r}
if(!("geofacet" %in% installed)) install.packages("geofacet")
require(geofacet)

# Define a grid that mimics the geographical distribution of the provinces
mygrid <- data.frame(
  code = c("LIM", "GT", "NW", "MP", "NC", "FS", "KZN", "EC", "WC"),
  name = c("Limpopo", "Gauteng", "North West", "Mpumalanga", "Northern Cape",
           "Free State", "KwaZulu-Natal", "Eastern Cape", "Western Cape"),
  row = c(1, 2, 2, 2, 3, 3, 3, 4, 4),
  col = c(3, 3, 2, 4, 1, 2, 3, 2, 1),
  stringsAsFactors = FALSE
)

# Plot the data with the geofaceting
ggplot(municipal, aes(Higher)) +
  geom_boxplot(col = "dark grey") +
  geom_density() +
  geom_rug() +
  facet_geo(~ ProvinceName, grid = mygrid) +
  scale_y_continuous(breaks = c(0, 0.2, 0.4)) +
  theme_bw() +
  labs(
    title = "Percentage of Population with higher education",
    caption = "Source: 2011 Census / Statistics South Africa"
  ) +
  xlab("% per municipality")
```

## Saving the map and attribute data

That's almost it for now! However, before finishing, we will save the map with the joined attribute data to the working directory as an R object.

```{r}
#| eval: false
save(municipal, file = "municipal.RData")
```

```{r}
#| include: false
if(!file.exists("municipal.RData")) save(municipal, file = "municipal.RData")
```

## Summary

This session has demonstrated that R is a powerful tool for drawing publication quality maps. The native `plot` functions for `sf` objects are useful as a quick way to draw a map and both `ggplot2` and `tmap` offer a range of functionality to customise their cartographic outputs to produce really nice looking maps. I tend to use `ggplot2` but that is really more out of habit than anything else as `tmap` might actually be the easier to use. It depends a bit on whether I am drawing static maps (usually in `ggplot2`) or interactive ones (probably better in `tmap`). There are other packages available, too, including [mapview](https://cran.r-project.org/web/packages/mapview/index.html){target="_blank"}, which the following code chunk uses (see also, [here](https://www.infoworld.com/article/3644848/astonishingly-easy-mapping-in-r-with-mapview.html){target="_blank"}), and [Leaflet to R](https://rstudio.github.io/leaflet/){target="_blank"}. Perhaps the key take-home point is that these maps can look at lot better than those produced by some conventional GIS and have the advantage that they can be linked to other analytically processes in R, as future sessions will demonstrate.

```{r}
if(!("mapview" %in% installed)) install.packages("mapview", dependencies = TRUE)
require(mapview)

mapview(municipal %>% mutate(No_schooling = round(No_schooling, 1)), 
        zcol = "No_schooling",
        layer.name = "% No Schooling",
        map.types = "Stamen.Watercolor",
        col.regions = colorRampPalette(rev(brewer.pal(9, "RdYlBu"))))
```

## Further reading

![](geospatial_health.jpg){width=100}


Chapter 2 on [Spatial data and R packages for mapping](https://www.paulamoraga.com/book-geospatial/sec-spatialdataandCRS.html){target="_blank"} from Geospatial Health Data by Paula Morga (2019)

![](geocomputation.png){width=100}

Chapter 9 on [Making maps with R](https://geocompr.robinlovelace.net/adv-map.html){target="_blank"} from Geocomputation with R by Robin Lovelace, Jakub Nawosad & Jannes Muenchow.

See also: [Elegant and informative maps with tmap](https://r-tmap.github.io/tmap-book/){target="_blank"}, which is a work in progress by Martijn Tennekes and Jakub Nowosad.
