{"title":"Base R","markdown":{"yaml":{"title":"Base R","subtitle":"A Brief Guide","execute":{"warning":false,"message":false}},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n![](Rlogo.svg){width=100}\n\n\nBase R is what you download from [CRAN](https://cran.r-project.org/){target=\"_blank\"}. You might think of it as classic R. A short introduction of 'the basics' is provided below. For a fuller introduction, see the software manual, [An Introduction to R](https://cran.r-project.org/manuals.html){target=\"_blank\"}. It is worth reading even if you end-up regularly using the Tidyverse variant of R described in the next session as there are some tasks that are (in my opinion) easier to do using Base R or by mixing it up a little.\n\n## Functions\n\nR is a functional programming language where functions 'do things' to objects. What they do is dependent upon the class/type and attributes of the objects that go into the function, and also on the arguments of the function.\n\nFor example, try typing the following into the R Console, which is the bottom left panel of R Studio. Type it alongside the prompt symbol, `>` then hit `Enter`/`Return`.\n\n```{r}\nround(10.32, digits = 0)\n```\n\nThis calls the function `round()`, which is operating on the numeric object, `10.32`. The argument `digits` specifies the number of digits to round to. It is set to zero in the example above.\n\nBecause `digits = 0` is the default value for the function, we could just write\n\n```{r}\nround(10.32)\n```\n\nand obtain the same answer as before. I know that `digits = 0` is the default value because, as I type the name of the function into the R Console, I see the arguments of the function and any default values appear.\n\n![](round.png)\n\nWe can also find out more about the function, including some examples of its use, by opening its help file.\n\n```{r}\n#| eval: false\n?round\n```\n\n</br>\nShould we wish to round 10.32 to one digit then we are no longer rounding to the default of zero decimal places and must therefore specify the argument explicitly (the default is no longer what we want).\n\n```{r}\nround(10.32, digits = 1)\n```\n\nThe following also works because it preserves the order of the arguments in the function.\n\n```{r}\nround(10.32, 1)\n```\n\nIn other words, if we do not specifically state that `x = 10.32` (where `x` is a numeric vector; here, 10.32) and `digits = 1` then they will be taken as the first and second arguments of the function. This requires care to make sure they genuinely are in the right order. If you aren't certain, then define the arguments explicitly because they will then work out of order.\n\n```{r}\nround(digits = 1, x = 10.32)\n```\n\n\n</br>\nIn the examples above, both the input to and output from the function are a `numeric` vector of type `double`. The input is:\n\n```{r}\nclass(10.32)\ntypeof(10.32)\n```\n\nThe output is:\n\n```{r}\nclass(round(10.32, digits = 1))\ntypeof(round(10.32, digits = 1))\n```\n\nNote how a function can be wrapped within a function, as in the example above: `class(round(...))`.\n\n\n</br>\nAt the moment we are using `x = 10.32`, which is a numeric vector of `length` 1,\n\n```{r}\nlength(10.32)\n```\n\nHowever, the `round()` function can operate on numeric vectors of other lengths too.\n\n```{r}\nround(c(1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7))\n```\n\nHere the combine function, `c` is used to create a vector of length 7, which is the input into `round()`. The output is of length 7 too.\n\n```{r}\nlength(round(c(1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7)))\n```\n\n![](hazard.gif){width=75}\n\n<font size = 3>There are **lots** of functions for R and I often forget what I need. Fortunately, there is  a large user community too and so a quick web search often helps me quickly find what I need. Don't be afraid to do a Google search for what you need.</font>\n\n###  Writing a new function\n\nWe can write our own functions. The following will take a number and report whether it is a prime number or not.\n\n```{r}\nis.prime <- function(x) {\n  if(x == 2) return(TRUE)\n  if(x < 2 | x %% floor(x) != 0) {\n    warning(\"Please enter an integer number above 1\")\n    return(NA)\n  }\n  y <- 2:(x-1)\n  ifelse(all(x%%y > 0), return(TRUE), return(FALSE))\n}\n```\n\nLet's try it.\n\n```{r}\nis.prime(2)\nis.prime(10)\nis.prime(13)\nis.prime(3.3)\n```\n\n\n</br>\nThere is quite a lot to unpack about the function. It is not all immediately relevant but it is instructive to have an overview of what it is doing. First of all the function takes the form\n\n````{verbatim}\nf <- function(x) {\n  ...\n}\n````\n\nwhere `x` is the input into the function in much the same way that `x` is the number to be rounded in `round(x = ...)`. It is a 'place holder' for the input into the function.\n\nStatements such as `if(x == 2)` are logical statements: `if(...)` is true then do whatever follows. If what is to be done spans over multiple lines, they are enclosed by 'curly brackets', `{...}`.\n\nThe statement `if(x < 2 | x %% floor(x) != 0)` in the function is also a logical statement with the inclusion of an `or` statement, denoted by `|`. What it is checking is whether `x < 2` **or** if `x` is a fraction. Had we needed to have both conditions to be met, then an `and` statement would be used, denoted by `&` instead of `|`. Note that `!` means not, so `!=` tests for not equal to and is the opposite of `==`, which tests for equality.\n\nWhere it says, `2:(x-1)`, this is equivalent to the function, `seq(from = 2, to = (x-1), by = 1)`. It generates a sequence of integer numbers from $2$ to $(x-1)$.\n\n```{r}\nx <- 10\n2 : (x - 1)\nseq(from = 2, to = (x-1), by = 1)\n```\n\n`ifelse()` is another logical statement. It takes the form, `ifelse(condition, a, b)`: if the `condition` is met then do `a`, else do `b`. In the prime number function it is checking whether dividing $x$ by any of the numbers from $2$ to $(x-1)$ generates a whole number.\n\nFinally, the function `return()` returns an output from the function; here, a logical vector of length 1 that is `TRUE`, `FALSE` or `NA` dependent upon whether $x$ is or is not a prime number, or if it is not a whole number above $1$.\n \nNote that in newer versions of R, functions can also take the form,\n\n````{verbatim}\nf <- \\(x) {\n  ...\n}\n````\n\nTherefore the following is exactly equivalent to before.\n\n```{r}\nis.prime <- \\(x) {\n  if(x == 2) return(TRUE)\n  if(x < 2 | x %% floor(x) != 0) {\n    warning(\"Please enter an integer number above 1\")\n    return(NA)\n  }\n  y <- 2:(x-1)\n  ifelse(all(x%%y > 0), return(TRUE), return(FALSE))\n}\n```\n\n## Objects and Classes\n\nOur function that checks for a prime number is stored in the object `is.prime`.\n\n```{r}\nclass(is.prime)\n```\n\nThere are other classes of object in R. Some of the most common are listed below.\n\n### Logical\n\nThe output from the `is.prime()` function is an example of an object of class logical because the answer is `TRUE` or `FALSE` (or `NA`, not applicable).\n\n```{r}\nx <- is.prime(10)\nprint(x)\nclass(x)\n```\n\nSome other examples:\n\n```{r}\ny <- 10 > 5\nprint(y)\nclass(y)\nz <- 2 == 5   # is 2 equal to 5?\nprint(z)\n```\n\n### Numeric\n\nWe have already seen that some objects are `numeric`.\n\n```{r}\nx <- mean(0:100)\nprint(x)\nclass(x)\n```\n\nThis presently is of type `double`; i.e. it allows for decimal places even where they are not required.\n\n```{r}\ntypeof(x)\n```\n\nbut it could be converted to class `integer` (a whole number with no decimal places).\n\n```{r}\nx <- as.integer(x)\nclass(x)\n```\n\n### Character\n\nOther classes include `character`. Note the difference between the `length()` of a character vector and the number of characters, `nchar()`, that any element of that vector contains.\n\n```{r}\nx <- \"Mapping and Modelling in R\"\nprint(x)\nlength(x)   # There is only one element in this vector\nnchar(x)    # And that element contains 26 letters\nclass(x)\ny <- paste(x, \"with Richard Harris\")\nprint(y)\nlength(y)   # There is still only one element\nnchar(y)    # But now it contains more letters\nclass(y)\nz <- unlist(strsplit(x, \" \"))\nprint(z)\nlength(z)   # The initial vectors has been split into 5 parts\nnchar(z)\nclass(z)\n```\n\n![](hazard.gif){width=75}\n\n<font size = 3>As the name suggests, `print` is a function that prints its contents to screen. Often it can be omitted in favour of referencing the object directly. For instance, in the example above, rather than typing `print(z)` it would be sufficient just to type `z`. Just occasionally though you will find that an object does not print as you intended when the function is omitted. If this happens, try putting `print` back in.</font>\n\n\n### Matrix\n\nAn example of a `matrix` is\n\n```{r}\nx <- matrix(1:9, ncol = 3)\nx\nncol(x)   # Number of columns\nnrow(x)   # Number of rows\nclass(x)\n```\n\nHere the argument `byrow` is changed from its default value of `FALSE` to be `TRUE`:\n\n```{r}\ny <- matrix(1:9, ncol = 3, byrow = TRUE)\n```\n\nThis result is equivalent to the transpose of the original matrix.\n\n```{r}\ny\nt(x)\n```\n\n### Data frame\n\nA `data.frame` is a table of data, such as,\n\n```{r}\ndf <- data.frame(Day = c(\"Mon\", \"Tues\", \"Wed\", \"Thurs\", \"Fri\", \"Sat\", \"Sun\"),\n                 Date = 20:26,\n                 Month = \"June\",\n                 Year = 2022)\ndf\nclass(df)\nncol(df)    # Number of columns\nnrow(df)    # Number of rows\nlength(df)  # The length is also the number of columns\nnames(df)   # The names of the variables in the data frame\n```\n\nNote that the length of each column should be equal in the specification of the data frame. The following will generate an error because the Date column is now too short. You might wonder why the Month and Year columns were fine previously when, in fact, they were give only one value, whereas there are 7 days and 7 dates. It is because R recycled them the requisite number of times (i.e. it gave all the rows the same value for Month and Year -- it recycled June and 2022 seven times). That option isn't available for the example below where there are 7 days but 6 dates.\n\n````{verbatim}\n# This will generate an error\ndf <- data.frame(Day = c(\"Mon\", \"Tues\", \"Wed\", \"Thurs\", \"Fri\", \"Sat\", \"Sun\"),\n                 Date = 20:25,\n                 Month = \"June\",\n                 Year = 2022)\n````\n\n### Factors\n\nEarlier versions of R would, by default, convert character fields in a data frame into factors. The equivalent operation now is,\n\n```{r}\ndf2 <- data.frame(Day = c(\"Mon\", \"Tues\", \"Wed\", \"Thurs\", \"Fri\", \"Sat\", \"Sun\"),\n                 Date = 20:26,\n                 Month = \"June\",\n                 Year = 2022, stringsAsFactors = TRUE)\n```\n\nTreating character fields as factors was clever but frustrating if you didn't realise it was happening and wanted the characters to remains as characters. The difference is not immediately obvious,\n\n```{r}\nhead(df, n= 2)    # with stringsAsFactors = FALSE (the current default)\nhead(df2, n = 2)  # with stringsAsFactors = TRUE  (the historic default)\n```\n\nThese appear to be the same but differences begin to be apparent in the following:\n\n```{r}\ndf$Day\ndf2$Day\ndf$Month\ndf2$Month\n```\n\nBasically, a `factor` is a categorical variable: it encodes which groups or categories (which `levels`) are to be found in the variable. Knowing this, it is possible to count the number of each group, as in,\n\n```{r}\nsummary(df2)\n```\n\nbut not\n\n```{r}\nsummary(df)\n```\n\n\n</br>\nFactors can be useful but do not always behave as you might anticipate. For example,\n\n```{r}\nx <- c(\"2021\", \"2022\")\nas.numeric(x)\n```\n\nis different from,\n\n```{r}\nx <- factor(c(\"2021\", \"2022\"))\nas.numeric(x)\n```\n\nThese days the defult is `stringsAsFactors = FALSE`, which is better when using functions such as `read.csv()` to read a .csv file into a `data.frame` in R.\n\n\n### Lists\n\nA `list` is a more flexible class that can hold together other types of object. Without a list, the following only works because the `1:3` are coerced from numbers in `x` to characters in `y` -- note the `\" \"` that appear around them, which shows they are now text. \n\n```{r}\nx <- as.integer(1:3)\nclass(x)\ny <- c(\"a\", x)\ny\nclass(y)\n```\n\nOn the other hand,\n\n```{r}\ny <- list(\"a\", x)\n```\n\ncreates a ragged list of two parts:\n\n```{r}\nclass(y)\ny\n```\n\nThe first part has the character `\"a\"` in it.\n\n```{r}\ny[[1]]\nclass(y[[1]])\n```\n\nThe second has the numbers 1 to 3 in it.\n\n```{r}\ny[[2]]\nclass(y[[2]])\n```\n\nNote that the length of the list is the length of its parts. Presently it is 2 but the following example has a length of three.\n\n```{r}\ny <- list(\"a\", x, df)\ny\nlength(y)\n```\n\n\n</br>\nThis should not be confused with the length of any one part.\n\n```{r}\nlength(y[[1]])\nlength(y[[2]])\nlength(y[[3]])\n```\n\n## Assignments\n\nThroughout this document I have used the assignment term `<-` to store the output of a function, as in `x <- as.integer(1:3)` and `y <- list(\"a\", x, df)`, and so forth. The `<-` is used to assign the result of a function to an object. You can, if you prefer use `=`. For example, all the following make the same assignment, which is to give `x` the value of 1.\n\n```{r}\nx <- 1\nx = 1\n1 -> x\n```\n\nPersonally, I avoid using `=` as an assignment for the following reasons.\n</br>\nFirst, not to confuse assignments with arguments,\n\n```{r}\nx <- round(10.32, digits = 1)   # I think this is a bit clearer\nx = round(10.32, digits = 1)    # and this a bit less so\n```\n\nSecond, to not confuse assignments with logical statements,\n\n```{r}\nx <- 1\ny <- 2\nz <- x == y   # Again, this is a bit clearer\nz = x == y    # and this not so much\n```\n\nThird -- but this is pedantic -- to avoid the following sort of situation which makes no sense mathematically...\n\n```{r}\nx = 1\ny = 2\nx = y\n```\n\n... but does in terms of what it really means:\n\n```{r}\nx <- 1\ny <- 2\nx <- y # Assign the value of y to x, overwriting its previous value\n```\n\n\n</br>\nWhich you use is a matter of personal preference and, of course, `=` has one less character than `<-` to worry about. However, this course is written with,\n\n`<-` (or `->`) is as assignment, as in `x <- 1`;\n\n`=` is the value of an argument, as in `round(x, digits = 1)`; and\n\n`==` is a logical test for equality, as in `x == y`.\n\n![](hazard.gif){width=75}\n\n<font size = 3>It is important to remember that R is **case sensitive**. An object called `x` is different from one called `X`; `y` is not the same as `Y` and so forth.</font>\n\n## Manipulating objects\n\nIn addition to passing objects to functions such as...\n\n```{r}\nx <- 0:100\nmean(x)\nsum(x)\nsummary(x)\nmedian(x)\nquantile(x, probs = c(0, 0.25, 0.5, 0.75, 1))\nhead(sqrt(x)) # The square roots of the first of x\ntail(x^2)     # The square roots of the last of x\nsd(x)         # The standard deviation of x\n```\n\n...there are other ways we may wish to interact with objects.\n\n### Mathematical operations\n\nMathematical operations generally operate on a pairwise basis between corresponding elements in a vector. For example,\n\n```{r}\nx <- 1\ny <- 3\nx + y\nx <- 1:5\ny <- 6:10\nx + y\nx * y   # Multiplication\nx / y   # Divisions\n```\n\nIf one vector is shorter that the other, values will be recycled. In the following example the results are $1\\times6$,  $2\\times7$,  $3\\times8$,  $4\\times9$  and *then* $5\\times6$ as `y` is recycled.\n\n```{r}\nx <- 1:5  # This is a vector of length 5\ny <- 6:9  # This is a vector of length 4\nx * y     # A vector of length 5 but some of y is recycled\n```\n\n### Subsets of objects\n\n#### Vectors\n\nIf `x` is a `vector` then `x[n]` is the nth element in the vector (the nth position, the nth item). To illustrate,\n\n```{r}\nx <- c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\")\nx[1]\nx[3]\nx[c(1, 3, 5)]\nx[length(x)]\n```\n\nThe notation `-n` can be used to exclude elements.\n\n```{r}\nx[-3]   # All of x except the 3rd element\nx[c(-1, -3, -5)]    # x without the 1st, 3rd and 5th elements\n```\n\n#### Matrices\n\nIf `x` is a `matrix` then `x[i, j]` is the value of the ith row of the jth column:\n\n```{r}\nx <- matrix(1:10, ncol = 2)\nx\nx[1, 1]     # row 1, column 1\nx[2, 1]     # row 2, column 1\nx[c(3, 5), 2]   # rows 3 and 5 of column 2\nx[nrow(x), ncol(x)]   # the final entry in the matrix\n```\n\n\n</br>\nAll of the values in the ith row can be selected using the form `x[i, ]`\n\n```{r}\nx[1, ]    # row 1\nx[3, ]    # row 3\nx[c(1, 5), ]  # rows 1 and 5\nx[c(-1, -3), ]  # All except the 1st and 3rd rows\n```\n\nSimilarly, all of the values in the jth column can be selected using the form `x[, j]`\n\n```{r}\nx[ ,1]    # column 1\nx[ ,2]    # column 2\nx[ , 1:2]   # columns 1 and 2\nx[-3 , 1:2]   # columns 1 and 2 except row 3\n```\n\n#### Data frames\n\nData frames are not unlike a matrix. \n\n```{r}\ndf <- data.frame(Day = c(\"Mon\", \"Tues\", \"Wed\", \"Thurs\", \"Fri\", \"Sat\", \"Sun\"),\n                 Date = 20:26,\n                 Month = \"June\",\n                 Year = 2022)\ndf[, 1]   # The first column\ndf[1, 1]  # The first row of the first column (Day)\ndf[2, 2]  # The second row of the second column (Date)\n```\n\nHowever, you can also reference the variable name directly, through the `x$variable` style notation,\n\n```{r}\ndf$Day\ndf$Day[1]\ndf$Date[2]\n```\n\nAlternatively, if you wish, with the square brackets, using the `[, \"variable\"]` format.\n\n```{r}\ndf[, \"Day\"]\ndf[1, \"Day\"]\ndf[2, \"Date\"]\n```\n\n#### Lists\n\nWe have already seen the use of **double** square brackets, `[[...]]` to refer to a part of a list:\n\n```{r}\nx <- 1:3\ny <- list(\"a\", x, df)\ny[[1]]\ny[[2]]\ny[[3]]\n```\n\nThe extension to this is to be able to refer to a specific element within a part of the list by combining it with the other notation. Some examples are:\n\n```{r}\ny[[1]][1]\ny[[2]][3]\ny[[3]]$Day\ny[[3]]$Day[1]\ny[[3]][2, \"Date\"]\n```\n\n![](hazard.gif){width=75}\n\n<font size = 3>The way to remember the difference between `[[...]]` and `[...]` is that the double square brackets reference a specific part of a list, for example `[[3]]`, the third part; the single square brackets reference a position or element in a vector, such as `[4]`, the fourth. Combining them, `[[3]][4]` is the 4th element of a vector where that vector forms the 3rd part of a list.</font>\n\n## Deleting objects and saving the workspace\n\nMy current working directory is,\n\n```{r}\ngetwd()\n```\n\nand it contains the following objects:\n\n```{r}\nls()\n```\n\nYours will be different. Remember, it can be useful to create a new project for a new collection of work that you are doing in R and then opening that project each time you start R will ensure that the working directory is that of the project. \n\nTo delete a specific object, use `rm()`,\n\n```{r}\nrm(z)\n```\n\nOr, more than one,\n\n```{r}\nrm(df, df2, is.prime)\n```\n\nTo save the workspace and all the objects it now contains use the `save.image()` function.\n\n```{r}\nsave.image(\"workspace1.RData\")\n```\n\nTo delete all the objects created in your workspace, use\n\n```{r}\nrm(list=ls())\n```\n\n![](hazard.gif){width=75}\n\n<font size = 3>It is a good idea to save a workspace with a new filename before deleting too much from your workspace to allow you to recover it if necessary. **Be especially careful** if you use `rm(list=ls())` as there is **no undo function**. The best you can do is load the workspace as it was the last time that you saved it.</font>\n\nTo (re)load a workspace, use `load()`.\n\n```{r}\nload(\"workspace1.RData\")\n```\n\n## Further reading\n\nThis short introduction to base R has really only scratched the surface. There are many books about R that provide a lot more detail but, to remind you, the manual that comes with the software is worth reading and probably the best place to start -- [An Introduction to R](https://cran.r-project.org/manuals.html){target=\"_blank\"}. It is thorough but also relatively short.\n\nDon't worry if not everything makes sense at this stage. The best way to learn R is to put it into practice and that is what we shall be doing in later sessions.\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"show","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"base.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.0.38","theme":"flatly","title":"Base R","subtitle":"A Brief Guide"},"extensions":{"book":{"multiFile":true}}}}}